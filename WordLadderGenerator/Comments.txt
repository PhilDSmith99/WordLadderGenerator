See this - Alternate solutions....
https://leetcode.com/problems/word-ladder/solution/

This bunch is from my alternate solution:

    // Lewis Carrol..........
    // https://www.geeksforgeeks.org/word-ladder-length-of-shortest-chain-to-reach-a-target-word/
    // Hybrid Dictionaries, Hashes, Lists etc.....
    // https://codereview.stackexchange.com/questions/174824/given-two-words-and-a-dictionarys-word-list-find-all-shortest-transformation-s
    // The above is a stronger example than below but I only have a finite time and will need to comment it etc....
    // https://bradfieldcs.com/algos/graphs/word-ladder/ - very clear paper
    // https://leetcode.com/problems/word-ladder-ii/discuss/375730/C-BFS-Solution-faster-than-94-and-less-than-100-memory
    // ALso see above link - some suggestions for improvements......
    // PLus book I bought - See page 131 - https://play.google.com/books/reader?id=3jddDwAAQBAJ&pg=GBS.PA130&hl=en


    .net core i.e. try it as a core project????

What was their point about sorting the file? Can I remove my sort?

Unit Test for processors do nit test word length etc as the validation is expected to be handled by the UI.

Your solution should deal with the case where the dictionary file is not in alphabetical order.

Multiple Ladders - Output also contains ladder detail. If single it just conatains ladder

Is the end word falling before the srart word really an issue????


    // Mocking File IO
// UNIT tEST - System.IO.Abstractions ..... http://dontcodetired.com/blog/post/Unit-Testing-C-File-Access-Code-with-SystemIOAbstractions
install-package System.IO.Abstractions.TestingHelpers
So both the above 2 packages were used to mock the fileio
Some test seem trival but they should always be in place as the complexity of the method mayn well expand over time.
Logging is rudamentry - Ideally I woul a framework.....
Logging: http://www.techtutorhub.com/article/how-to-add-logging-in-dot-net-core-console-application/84


// Karl Bamfords Book - It took me back - https://play.google.com/store/books/details?id=3jddDwAAQBAJ&rdid=book-3jddDwAAQBAJ&rdot=1&source=gbs_vpt_read&pcampaignid=books_booksearch_viewport
// Maybe reference the above......
// To Read Up On:
// SOLID... Discuss each letter breifly or at least include some detail for each step in my descrition
// e.g. Validators, IO etc in seperatre classes. Other optiosnf or seperation - extension methods, seperate projects, their own layers etc.....
// New C# Features
// Look into namespace conventions
// Classes such as Logger, WordLadder etc were originally static as console app.
// Decided to make them instances so I could add interfaces etc....

// List.AddRange - Does it actually add pointers or copies? We want pointers to create a Linked List?
// I have Vaidation at the start of Wordlist2 - is it needed? Discuss implications.....

// ReadDictionary and ValidWord can become IEnumerable if I end up not trying to find start/end etc

// To Document/Discuss:
// Lewis Carroll, BFS, Degree material etc
// Why I use Linq To Objects.....
// Efficiency - If it were massive i'd use a Database etc......, Get ride of all non 4 char words before we process.
// Plus description of Data structures etc using in algorhims - Dictionary, Hashset, What was the older one?
// Why I dont Like var, Ive used properties rather than fields
// Could replace properties with fields but most people use properties
// Also the volume of XML Comments
// The logger and IO are placed in a seperate Class (SOLID - Single Responsibility Principle). Logger would ideally be placed with ......
// Ilist, Ienumerable versus List
// DiffersByACharacter - Considered putting it in Validator and making argument names generic but too specific - words must be equal - didnt want to add in logic etc for efficiency....
// Could check in WordLadder methods all strings are of correct length etc - but where does it end? Efficiency? Add this to the notes...

// https://stackoverflow.com/questions/23989677/file-readalllines-or-stream-reader
// https://www.techiedelight.com/check-string-consists-alphanumeric-characters-csharp/
// https://stackoverflow.com/questions/230973/how-to-convert-all-strings-in-liststring-to-lower-case-using-linq
// https://docs.microsoft.com/en-us/dotnet/api/system.io.file.readlines?view=net-5.0
// words = words.ConvertAll(d => d.ToLower());
// I'd use a DB and not LINQ if there were messive volumes....
// Could use words.Contains(startWord) but we have to find the Index anyhow
// Could use For but I prefer LINQ when getting the subset of words
// See if I need a check on createresultsfile if the start and end fall directly after each other i.e. only 2 resultant items.....



ProgramTest should have used the MockFileSystem like the FileIO Tests.....
If multiple ladders found headers added.....
Add FileIO Mocks to Program Level Tests - Or at least highlight…. 

// Lewis Carrol..........
// https://www.geeksforgeeks.org/word-ladder-length-of-shortest-chain-to-reach-a-target-word/
// Hybrid Dictionaries, Hashes, HashSet, Lists etc.....
// https://codereview.stackexchange.com/questions/174824/given-two-words-and-a-dictionarys-word-list-find-all-shortest-transformation-s
// The above is a stronger example than below but I only have a finite time and will need to comment it etc....
// https://bradfieldcs.com/algos/graphs/word-ladder/ - very clear paper
// https://leetcode.com/problems/word-ladder-ii/discuss/375730/C-BFS-Solution-faster-than-94-and-less-than-100-memory
// ALso see above link - some suggestions for improvements......
// PLus book I bought - See page 131 - https://play.google.com/books/reader?id=3jddDwAAQBAJ&pg=GBS.PA130&hl=en
